BUILD_TIME :: #run current_time_consensus();

MAJOR :: 0;
MINOR :: 0;
PATCH :: 1;

YABAI_MSG_FAILURE :: "\x07";
YABAI_SOCKET_PATH :: #run -> string {
    #import "System";
    username, success := get_username();
    return tprint("/tmp/yabai_%.socket", username);
}

Launch_Args :: struct {
    verbose: bool;
}

Event_Tap :: struct {
    handle:     CFMachPortRef;
    runloop:    CFRunLoopSourceRef;
    mask:       CGEventMask;
    my_context: #Context;
}

Yabai_Bind :: struct {
    selector: string;
    flags:    u64;
    key:      u16;
}

Hotkey :: struct {
    key:    u16;
    flags:  u64;
    action: #type () -> ();
} hotkeys: [..]Hotkey;

/*
 * The Socket module does not have this struct definition by default.
 * This struct definition was generated by adding libc_path/sys/un.h
 * to included files and running Socket/generate.jai.
 *
 *   - Ã¥vi, 28 may 2025.
*/
sockaddr_un :: struct {
    sun_len:    u8; /* sockaddr len including null */
    sun_family: sa_family_t; /* [XSI] AF_UNIX */
    sun_path:   [104] u8; /* [XSI] path name (gag) */
}

socket_open :: inline () -> (success: bool, fd: Socket) {
    fd := socket(AF_UNIX, SOCK.STREAM, 0);
    return fd != -1, fd;
}

socket_connect :: inline (fd: Socket, socket_path: string) -> success: bool {
    socket_address: sockaddr_un;
    socket_address.sun_family = AF_UNIX;
    memcpy(socket_address.sun_path.data, socket_path.data, socket_path.count);
    return connect(fd, cast(*sockaddr) *socket_address, size_of(type_of(socket_address))) != -1;
}

socket_close :: inline (fd: Socket) {
    shutdown(fd, SHUT.RDWR);
    close(fd);
}

yabai :: (message: string) -> (success: bool, response: string) {
    success, fd := socket_open();
    if !success return false, "failed to open socket";

    defer socket_close(fd);
    success = socket_connect(fd, YABAI_SOCKET_PATH);
    if !success return false, "failed to connect to socket";

    header_size  := size_of(s32);
    payload_size := message.count+2;
    data_size    := header_size + payload_size;

    data := alloc(data_size,, temp);
    memcpy(data, *payload_size, header_size);

    payload := data + header_size;
    memcpy(payload, message.data, message.count);
    memset(payload+message.count, 0, 2);

    success = send(fd, data, xx data_size, 0) != -1;
    if !success return false, "failed to send payload";

    shutdown(fd, SHUT.WR);
    sb: String_Builder;
    sb.allocator = temp;

    result := true;
    while true {
        rsp: [255]u8;
        bytes_read := read(fd, rsp.data, rsp.count-1);
        if bytes_read <= 0 break;

        if (rsp[0] == YABAI_MSG_FAILURE[0]) {
            result = false;
            append(*sb, rsp.data+1, bytes_read-1);
        } else {
            append(*sb, rsp.data, bytes_read);
        }
    }

    return result, builder_to_string(*sb);
}

shell :: inline (command: string) {
    cpid := fork();
    if cpid == 0 {
        setsid();
        exec: []*u8 = .["/bin/zsh", "-c", command.data, null];
        status_code := execvp(exec[0], exec.data);
        exit(status_code);
    }
}

bind :: (action: Code, flags: u64, key: u16) #expand {
    array_add(*hotkeys, .{
        key    = key,
        flags  = flags,
        action = () {
            #insert action;
        }
    });
}

shell_bind :: (command: string, flags: u64, key: u16) #expand {
    bind(#code { shell(#run tprint("%", command)); }, flags, key);
}

yabai_bind :: (command: string, flags: u64, key: u16) #expand {
    bind(#code { yabai(#run tprint("%", command)); }, flags, key);
}

yabai_bind :: (command: string, mb: []Yabai_Bind) -> string {
    bind :: (action: string, flags: u64, key: u16) -> string {
        s := #string DONE
        array_add(*hotkeys, .{
            key    = %,
            flags  = %,
            action = () {
                %
            }
        });
        DONE
        return tprint(s, key, flags, action);
    }

    sb: String_Builder;
    for mb append(*sb, bind(tprint("yabai(\"%\x00%\");", command, it.selector), it.flags, it.key));
    return builder_to_string(*sb);
}

event_tap_callback :: (proxy: CGEventTapProxy, type: CGEventType, event: CGEventRef, user_data: *void) -> event: CGEventRef  #c_call {
    data := cast(*Event_Tap) user_data;
    push_context data.my_context {
        defer reset_temporary_storage();

        if type == {
        case kCGEventTapDisabledByTimeout; #through;
        case kCGEventTapDisabledByUserInput;
            CGEventTapEnable(data.handle, true);

        case kCGEventKeyDown;
            flags := CGEventGetFlags(event);
            key   := CGEventGetIntegerValueField(event, kCGKeyboardEventKeycode);

            for hotkeys {
                if it.key != key continue;

                if (it.flags & Mod_Alt)     == (flags & Mod_Alt)     &&
                   (it.flags & Mod_Shift)   == (flags & Mod_Shift)   &&
                   (it.flags & Mod_Cmd)     == (flags & Mod_Cmd)     &&
                   (it.flags & Mod_Control) == (flags & Mod_Control) &&
                   (it.flags & Mod_Fn)      == (flags & Mod_Fn) {
                    it.action();
                    return null;
                }
            }
        }

        return event;
    }
}

event_tap_begin :: () -> success: bool {
    event_tap            := New(Event_Tap);
    event_tap.my_context  = context;
    event_tap.mask        = 1 << kCGEventKeyDown;
    event_tap.handle      = CGEventTapCreate(kCGSessionEventTap,
                                             kCGHeadInsertEventTap,
                                             kCGEventTapOptionDefault,
                                             event_tap.mask,
                                             event_tap_callback,
                                             event_tap);

    result := event_tap.handle && CGEventTapIsEnabled(event_tap.handle);
    if result {
        event_tap.runloop = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, event_tap.handle, 0);
        CFRunLoopAddSource(CFRunLoopGetMain(), event_tap.runloop, kCFRunLoopCommonModes);
    }

    return result;
}

check_privileges :: inline () -> success: bool {
    ApplicationServices           :: #system_library "ApplicationServices";
    CoreFoundation                :: #system_library "CoreFoundation";
    AXIsProcessTrustedWithOptions :: (options: CFDictionaryRef) -> bool #foreign ApplicationServices;
    kAXTrustedCheckOptionPrompt   : CFStringRef #elsewhere CoreFoundation;

    options := CFDictionaryCreate(kCFAllocatorDefault,
                                  xx *kAXTrustedCheckOptionPrompt,
                                  xx *kCFBooleanTrue,
                                  1,
                                  *kCFCopyStringDictionaryKeyCallBacks,
                                  *kCFTypeDictionaryValueCallBacks);
    defer CFRelease(options);
    return AXIsProcessTrustedWithOptions(options);
}

main :: () {
    success := check_privileges();
    if !success {
        print("could not access accessibility api; abort..\n");
        exit(1);
    }

    success = event_tap_begin();
    if !success {
        print("could not launch event_tap; abort..\n");
        exit(1);
    }

    add_keymap();
    CFRunLoopRun();

    /*
    success, args, is_set := parse_arguments(Launch_Args);
    if !success exit(1);

    if args.verbose print("verbose!!\n");
    if is_set.message {
        print("message: %\n", args.message);
    }

    print_stack_trace(context.stack_trace);
    print("build time: %\n", calendar_to_string(to_calendar(BUILD_TIME, .LOCAL)));
    */
}

#load "qes.jai";
#load "keymap.jai";

#import "Basic";
#import "Command_Line";
#import "Socket";
#import "Posix";
#import "macos";
